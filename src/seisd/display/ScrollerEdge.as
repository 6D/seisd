package seisd.display{	import flash.display.DisplayObject;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.Point;		/**	 * ...	 * @author Vamoss	 */	public class ScrollerEdge extends MovieClipBase	{				/// Velocidade da suavização		public var suavization:Number = .09;				/// Velocidade do movimento		public var velocity:Number = 5;				/// Area sensível ao movimento		public var sensibilityBorder:Number = 150;				/// Alvo para fazer scroll		private var _target:DisplayObject;				/// Destino x e y do scroll		private var _destiny:Point = new Point();				private var mouseIsOver:Boolean = false;		public function ScrollerEdge()		{					}				/**		 * start the enterframe verification		 */		public function start():void		{			if(target){				addEventListener(Event.ENTER_FRAME, enterFrame);				addEventListener(MouseEvent.ROLL_OVER, mouseOver);				addEventListener(MouseEvent.ROLL_OUT, mouseOut);						}		}				/*		 * Pause the enterframe verification		 **/		public function cancel():void		{			removeEventListener(Event.ENTER_FRAME, enterFrame);			removeEventListener(MouseEvent.ROLL_OVER, mouseOver);			removeEventListener(MouseEvent.ROLL_OUT, mouseOut);					}				/*		 * Back to the top left position		 **/		public function reset():void		{			destiny = new Point();		}						private function enterFrame(e:Event = null):void		{			distribute();		}				private function distribute(immediately:Boolean = false):void		{			if (target && enabled) {				if (mouseIsOver) {					var acceleration:Point = new Point();										//Calculo horizontal					if (_target.width > ww)					{						if (mouseX < sensibilityBorder ) {							acceleration.x = 1 - mouseX / sensibilityBorder;						}else if (mouseX > ww - sensibilityBorder) {							acceleration.x = (mouseX - (ww - sensibilityBorder)) / sensibilityBorder * -1;						}					}										//Calculo vertical					if (_target.height > hh)					{						if(mouseY < sensibilityBorder ) {							acceleration.y = 1 - mouseY /sensibilityBorder;						}else if (mouseY > hh - sensibilityBorder) {							acceleration.y = (mouseY - (hh - sensibilityBorder)) / sensibilityBorder * -1;						}					}										//Linear acceleration					acceleration.x *= velocity;					acceleration.y *= velocity;										//Exponencial acceleration					acceleration.x *= Math.abs(acceleration.x);					acceleration.y *= Math.abs(acceleration.y);										_destiny.x += acceleration.x;					_destiny.y += acceleration.y;				}										//Limita na área ww e hh				if (_destiny.x < ww - _target.width) _destiny.x = ww - _target.width;				if (_destiny.y < hh - _target.height) _destiny.y = hh - _target.height;				if (_destiny.x > 0) _destiny.x = 0;				if (_destiny.y > 0) _destiny.y = 0;								if (immediately) {					_target.x = _destiny.x;					_target.y = _destiny.y;				}else{					//Suaviza movimento					_target.x += (_destiny.x - _target.x) * suavization;					_target.y += (_destiny.y - _target.y) * suavization;				}			}		}				protected function mouseOver(e:MouseEvent):void		{			mouseIsOver = true;		}				protected function mouseOut(e:MouseEvent):void		{			mouseIsOver = false;			distribute();		}				public override function setSize(w:Number, h:Number, immediately:Boolean = false):void		{			super.setSize(w, h);						distribute(immediately);		}				/// Alvo para fazer scroll		public function get target():DisplayObject { return _target; }		public function set target(value:DisplayObject):void		{			_target = value;			addChild(_target);			distribute(true);		}				/// Destino x e y do scroll		public function get destiny():Point	{ return _destiny; }				public function set destiny(value:Point):void		{			_destiny = value;		}	}	}