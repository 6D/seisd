package seisd.display {	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.geom.Matrix;	import flash.geom.Point;		/**	 * ...	 * @author Vamoss	 */	public class ScrollerFollow extends MovieClipBase {		private var mouseIsOver:Boolean = false;				///Velocidade do movimento		public var velocity:Number = .09;				///Area sensível ao movimento		public var sensibilityBorder:Number = 200;				///Volta automaticamente para o centro quando o mouse estiver fora		public var autoCenter:Boolean = true;				private var _target:DisplayObject;		private var destiny:Point = new Point();		public function ScrollerFollow() {		}				/**		 * start the enterframe verification		 */		public function start():void {			if(target){				addEventListener(Event.ENTER_FRAME, enterFrame);				addEventListener(MouseEvent.MOUSE_OVER, mouseOver);				addEventListener(MouseEvent.MOUSE_OUT, mouseOut);						}		}				/*		 * Pause the enterframe verification		 **/		public function cancel():void {			removeEventListener(Event.ENTER_FRAME, enterFrame);			removeEventListener(MouseEvent.MOUSE_OVER, mouseOver);			removeEventListener(MouseEvent.MOUSE_OUT, mouseOut);					}					private function enterFrame(e:Event = null):void {			distribute();		}				private function distribute(immediately:Boolean = false):void {			if(target){				//Move layer dentro do range estipulado				if (mouseIsOver && enabled) {					if (_target.width > ww && (mouseX < sensibilityBorder  || mouseX > ww - sensibilityBorder)) {						//% * total + align						destiny.x = -(mouseX / ww) * (_target.width - ww);					}										if (_target.height > hh && (mouseY < sensibilityBorder  || mouseY > hh - sensibilityBorder)) {						destiny.y = -(mouseY / hh) * (_target.height - hh);					}									//Centraliza					destiny.x += _target.width /2;					destiny.y += _target.height /2;				}else if(autoCenter){					//Centraliza					destiny.x = _target.width / 2 - (_target.width - ww) / 2;					destiny.y = _target.height / 2 - (_target.height - hh) / 2;				}								//Suaviza movimento				if (!immediately && enabled) {					_target.x += (destiny.x - _target.x) * velocity;					_target.y += (destiny.y - _target.y) * velocity;										var _zeroX:Number = _target.width * .5;					var _zeroY:Number = _target.height * .5;										if (_target.x > _zeroX) _target.x = _zeroX;					if (_target.y > _zeroY) _target.y = _zeroY;					if (_target.x < _zeroX + ww - _target.width) _target.x = _zeroX + ww - _target.width;					if (_target.y < _zeroY + hh - _target.height) _target.y = _zeroY + hh - _target.height;				}else{					_target.x = destiny.x;					_target.y = destiny.y;				}			}		}				private function mouseOver(e:MouseEvent):void {			mouseIsOver = true;		}				private function mouseOut(e:MouseEvent):void {			mouseIsOver = false;			distribute();		}				public override function setSize(w:Number, h:Number, immediately:Boolean = false):void {			super.setSize(w, h, immediately);						//this.x = ww / 2;			//this.y = hh / 2;						distribute(immediately);		}				public function get target():DisplayObject {			return _target;		}				public function set target(t:DisplayObject):void {			_target = t;			addChild(_target);			distribute(true);		}	}	}